import os
import re
import time
import ast
import json
import streamlit as st
import requests

from dotenv import load_dotenv
from datetime import datetime, timedelta
from crewai import Agent, Task, Crew, LLM
from amadeus import Client, ResponseError
from crewai.tools import tool
from tabulate import tabulate

# Load env variables
load_dotenv()
GOOGLE_API_KEY = os.getenv("GOOGLE_PLACES_API_KEY")
# === LLM: Groq (you can change to a smaller model if you hit rate limits) ===
llm = LLM(
    model="llama-3.3-70b-versatile",
    api_key=os.getenv("GROQ_API_KEY"),
    base_url="https://api.groq.com/openai/v1"
)

# === Amadeus Setup ===
amadeus = Client(
    client_id=os.getenv("AMADEUS_CLIENT_ID"),
    client_secret=os.getenv("AMADEUS_CLIENT_SECRET"),
    hostname="test" if os.getenv("AMADEUS_ENV") == "test" else "production"
)

# === Helpers ===
def safe_llm_call(*args, max_retries=3, **kwargs):
    """Call llm.call with simple retry on rate limit-like errors."""
    for attempt in range(max_retries):
        try:
            return llm.call(*args, **kwargs)
        except Exception as e:
            s = str(e).lower()
            if "rate limit" in s or "tpm" in s or "rate_limit" in s or "ratelimit" in s or "rate_limit_exceeded" in s:
                wait = 5 * (attempt + 1)
                print(f"⚠️ LLM rate limit detected, sleeping {wait}s and retrying... ({attempt+1}/{max_retries})")
                time.sleep(wait)
                continue
            raise

def extract_json_from_text(text: str):
    """Attempt to extract JSON object from an LLM reply (strip code fences etc)."""
    if not isinstance(text, str):
        return None
    # If text already starts with { or [, try direct load
    txt = text.strip()
    # Remove Markdown code fences
    txt = re.sub(r"```(?:json)?", "", txt, flags=re.IGNORECASE).strip()
    # Find first { and last } (best-effort)
    start = txt.find("{")
    end = txt.rfind("}")
    if start != -1 and end != -1 and end > start:
        candidate = txt[start:end+1]
        try:
            return json.loads(candidate)
        except Exception:
            pass
    # Try to directly json.loads
    try:
        return json.loads(txt)
    except Exception:
        pass
    # Try ast.literal_eval
    try:
        return ast.literal_eval(txt)
    except Exception:
        pass
    return None

def parse_date_str(date_str: str):
    """
    Parse human date like '25th September' or '25 Sep 2025' into 'YYYY-MM-DD'.
    If year missing, pick current year or next year if that date already passed.
    """
    if not date_str:
        return None
    s = date_str.strip()
    # remove ordinals
    s = re.sub(r"(\d+)(st|nd|rd|th)", r"\1", s, flags=re.IGNORECASE)
    s = s.replace(",", "").strip()
    now = datetime.now()
    formats = [
        "%Y-%m-%d", "%d %B %Y", "%d %b %Y", "%d %B", "%d %b",
        "%d-%m-%Y", "%d/%m/%Y", "%d %m %Y", "%Y/%m/%d"
    ]
    for fmt in formats:
        try:
            dt = datetime.strptime(s, fmt)
            # if format lacked year, add logic below
            if "%Y" not in fmt:
                dt = dt.replace(year=now.year)
                if dt.date() < now.date():
                    dt = dt.replace(year=now.year + 1)
            return dt.strftime("%Y-%m-%d")
        except Exception:
            continue
    # Fallback: try parsing only day and month words (e.g., "25 September")
    m = re.match(r"^(\d{1,2})\s+([A-Za-z]+)$", s)
    if m:
        day = int(m.group(1))
        month_name = m.group(2)
        try:
            dt = datetime.strptime(f"{day} {month_name} {now.year}", "%d %B %Y")
        except Exception:
            try:
                dt = datetime.strptime(f"{day} {month_name} {now.year}", "%d %b %Y")
            except Exception:
                return None
        if dt.date() < now.date():
            dt = dt.replace(year=now.year + 1)
        return dt.strftime("%Y-%m-%d")
    # If the string already looks like YYYY, try to return it
    if re.match(r"^\d{4}-\d{2}-\d{2}$", s):
        return s
    return None

# Common fallback mapping for Indian city names
FALLBACK_IATA = {
    "bangalore": "BLR",
    "bengaluru": "BLR",
    "bombay": "BOM",
    "mumbai": "BOM",
    "delhi": "DEL",
    "new delhi": "DEL",
    "chenai": "MAA",  # note: common typo; MAA is Chennai
    "chennai": "MAA",
    "kolkata": "CCU",
    "calcutta": "CCU",
}
def get_google_place_details(hotel_name: str, city_code: str):
    """
    Fetch hotel details from Google Places API using text search + details API.
    Returns dict with rating, photo_url, user_ratings_total, etc.
    """
    if not GOOGLE_API_KEY:
        return None

    try:
        # Step 1: Text Search
        query = f"{hotel_name} {city_code}"
        textsearch_url = f"https://maps.googleapis.com/maps/api/place/textsearch/json"
        params = {"query": query, "key": GOOGLE_API_KEY}
        resp = requests.get(textsearch_url, params=params).json()
        if not resp.get("results"):
            return None

        place = resp["results"][0]
        place_id = place.get("place_id")

        # Step 2: Place Details
        details_url = f"https://maps.googleapis.com/maps/api/place/details/json"
        fields = "name,rating,user_ratings_total,formatted_address,photos,website"
        d_params = {"place_id": place_id, "fields": fields, "key": GOOGLE_API_KEY}
        d_resp = requests.get(details_url, params=d_params).json()
        if not d_resp.get("result"):
            return None

        result = d_resp["result"]

        # Construct photo URL if available
        photo_url = None
        if "photos" in result and result["photos"]:
            ref = result["photos"][0]["photo_reference"]
            photo_url = f"https://maps.googleapis.com/maps/api/place/photo?maxwidth=800&photoreference={ref}&key={GOOGLE_API_KEY}"

        return {
            "google_rating": result.get("rating"),
            "google_reviews": result.get("user_ratings_total"),
            "google_address": result.get("formatted_address"),
            "google_website": result.get("website"),
            "google_photo": photo_url
        }
    except Exception as e:
        print(f"Google Places error: {e}")
        return None

def get_iata_code(city_name: str):
    """
    Convert a city/airport name to its IATA code using Amadeus API (best effort).
    Returns None if not found.
    """
    if not city_name:
        return None
    name = city_name.strip()
    # If already 3-letter code, return uppercase
    if re.fullmatch(r"[A-Za-z]{3}", name):
        return name.upper()
    # First try Amadeus lookup
    try:
        resp = amadeus.reference_data.locations.get(keyword=name, subType=["CITY", "AIRPORT"])
        if resp and getattr(resp, "data", None):
            first = resp.data[0]
            iata = first.get("iataCode") or first.get("id")
            if iata:
                return iata.upper()
    except Exception:
        # ignore and fallback
        pass
    # fallback mapping
    key = name.lower()
    return FALLBACK_IATA.get(key)

# === Tools: search_flights (unchanged except returns origin/destination/currency) ===
# === Helpers for Amadeus flight search ===
def _search_flights(origin: str, destination: str, departure_date: str, currency: str = "INR", return_date: str = None):
    """Search flights using Amadeus API (plain function, safe for direct calls)."""
    try:
    
        params = {
            "originLocationCode": origin,
            "destinationLocationCode": destination,
            "departureDate": departure_date,
            "adults": 1,
            "currencyCode": currency
        }
        if return_date:
            params["returnDate"] = return_date

        if non_stop:
            params["nonStop"] = "true"

        response = amadeus.shopping.flight_offers_search.get(**params)

        results = []
        for offer in response.data[:8]:
            out_itin = offer["itineraries"][0]
            out_segments = out_itin["segments"]
            out_first = out_segments[0]
            out_last = out_segments[-1]

            flight_data = {
                "airline": offer.get("validatingAirlineCodes", ["N/A"])[0],
                "price": offer["price"]["total"],
                "currency": offer["price"].get("currency", currency),
                "origin": out_first["departure"].get("iataCode") or origin,
                "destination": out_last["arrival"].get("iataCode") or destination,
                "departure": out_first["departure"]["at"],
                "arrival": out_last["arrival"]["at"],
                "stops": max(len(out_segments) - 1, 0),
                "duration": out_itin.get("duration")
            }

            if return_date and len(offer["itineraries"]) > 1:
                ret_itin = offer["itineraries"][1]
                ret_segments = ret_itin["segments"]
                r_first = ret_segments[0]
                r_last = ret_segments[-1]
                flight_data.update({
                    "return_origin": r_first["departure"].get("iataCode"),
                    "return_destination": r_last["arrival"].get("iataCode"),
                    "return_departure": r_first["departure"]["at"],
                    "return_arrival": r_last["arrival"]["at"],
                    "return_stops": max(len(ret_segments) - 1, 0),
                    "return_duration": ret_itin.get("duration"),
                })

            results.append(flight_data)
        return results
    except ResponseError as error:
    # Amadeus gives detailed message in response / body
        details = None
        try:
            details = error.response.body
        except:
            details = str(error)

        return {"error": f"Amadeus API error: {details}"}

# === Hotel Search ===
def _search_hotels(city_code: str, check_in: str, check_out: str, adults: int = 1, currency: str = "INR"):
    """
    Search hotels in a given city using Amadeus API and enrich with Google Places.
    """
    try:
        # Step 1: Get hotel IDs for the city
        hotel_list = amadeus.reference_data.locations.hotels.by_city.get(cityCode=city_code)
        if not hotel_list.data:
            return {"error": f"No hotels found in city {city_code}"}

        hotel_ids = [h.get("hotelId") for h in hotel_list.data if h.get("hotelId")]
        if not hotel_ids:
            return {"error": f"No valid hotel IDs found in {city_code}"}

        # Step 2: Fetch hotel offers
        response = amadeus.shopping.hotel_offers_search.get(
            hotelIds=",".join(hotel_ids[:10]),
            checkInDate=check_in,
            checkOutDate=check_out,
            adults=adults,
            currency=currency,
            roomQuantity=1,
        )

        if not response.data:
            return {"error": f"No hotel offers available for {city_code} in sandbox data."}

        results = []
        for hotel in response.data[:8]:  # take first 8 results
            hotel_info = hotel.get("hotel", {})
            offer = hotel.get("offers", [{}])[0]

            base = {
                "name": hotel_info.get("name"),
                "address": hotel_info.get("address", {}).get("lines", ["?"])[0],
                "category": hotel_info.get("hotelCategory"),
                "price": offer.get("price", {}).get("total"),
                "currency": offer.get("price", {}).get("currency", currency),
                "check_in": offer.get("checkInDate"),
                "check_out": offer.get("checkOutDate"),
                "image": (hotel_info.get("media") or [{}])[0].get("uri"),
                "amenities": hotel_info.get("amenities"),
            }

            # 🔹 Enrich with Google Places details
            g_details = get_google_place_details(hotel_info.get("name"), city_code)
            if g_details:
                base.update(g_details)  # adds google_rating, google_reviews, google_photo, etc.
                if g_details.get("google_photo"):
                    base["image"] = g_details["google_photo"]

            results.append(base)

        return results

    except ResponseError as error:
        details = None
        try:
            details = error.response.body
        except:
            details = str(error)
        return {"error": f"Amadeus API error: {details}"}

def _search_attractions(city_code: str, limit: int = 5):
    """
    Search top attractions (points of interest) in a city using Amadeus API.
    Returns a list of attractions with name, category, tags, lat/lon.
    """
    try:
        response = amadeus.reference_data.locations.points_of_interest.get(
            cityCode=city_code,
            page={"limit": limit}
        )

        if not response.data:
            return {"error": f"No attractions found for {city_code}"}

        results = []
        for poi in response.data[:limit]:
            results.append({
                "name": poi.get("name"),
                "category": poi.get("category", "N/A"),
                "tags": poi.get("tags", []),
                "lat": poi.get("geoCode", {}).get("latitude"),
                "lon": poi.get("geoCode", {}).get("longitude"),
            })

        return results

    except ResponseError as error:
        try:
            details = error.response.body
        except:
            details = str(error)
        return {"error": f"Amadeus API error: {details}"}



# === CrewAI Tool wrapper ===
@tool("search_flights")
def search_flights_tool(origin: str, destination: str, departure_date: str, currency: str = "INR", return_date: str = None):
    """CrewAI Tool wrapper for Amadeus flight search."""
    return _search_flights(origin, destination, departure_date, currency, return_date)

@tool("search_hotels")
def search_hotels_tool(city_code: str, check_in: str, check_out: str, adults: int = 1, currency: str = "INR"):
    """Search hotels in a city by IATA city code using Amadeus API."""
    return _search_hotels(city_code, check_in, check_out, adults, currency)

# === parse_flight_query tool using LLM but with post-processing ===
@tool("parse_flight_query")
def parse_flight_query(query: str):
    """Parse a natural language flight request into structured parameters (best-effort)."""
    # Ask LLM to return strict JSON only (but we'll robustly extract it)
    prompt = f"""
You are a flight query parser. Extract the details from this user query and return strictly a JSON object (no extra commentary).

User query:
\"\"\"{query}\"\"\"

Return JSON with keys:
- origin: city name or IATA code (e.g., "Bangalore" or "BLR")
- destination: city name or IATA code (e.g., "Delhi" or "DEL")
- departure_date: date (YYYY-MM-DD or human readable like '25 September' or '25 Sep 2025')
- return_date: (optional) date in same formats or null
- adults: integer (default 1)
- non_stop: true/false (default false)
- currency: 3-letter code (default INR)

Only return the JSON object (no explanation). Example:
{{"origin":"Bangalore","destination":"Delhi","departure_date":"25 September","return_date":null,"adults":1,"non_stop":false,"currency":"INR"}}
"""
    # call LLM with retry
    raw = safe_llm_call(prompt)

    parsed = extract_json_from_text(raw)
    if not parsed:
        # fallback: try some regex extraction if LLM does not return usable json
        # very small heuristic fallback
        parsed = {}
        m_from = re.search(r"from\s+([A-Za-z ]+)\s+to\s+([A-Za-z ]+)", query, re.IGNORECASE)
        if m_from:
            parsed["origin"] = m_from.group(1).strip()
            parsed["destination"] = m_from.group(2).strip()
        d = re.search(r"on\s+([0-9]{1,2}(?:st|nd|rd|th)?\s+[A-Za-z]+(?:\s*\d{4})?)", query, re.IGNORECASE)
        if d:
            parsed["departure_date"] = d.group(1).strip()
        r = re.search(r"return(?:ing)?\s+on\s+([0-9]{1,2}(?:st|nd|rd|th)?\s+[A-Za-z]+(?:\s*\d{4})?)", query, re.IGNORECASE)
        if r:
            parsed["return_date"] = r.group(1).strip()
        a = re.search(r"(\d+)\s+adult", query, re.IGNORECASE)
        parsed["adults"] = int(a.group(1)) if a else 1
        parsed["non_stop"] = bool(re.search(r"non-?stop", query, re.IGNORECASE))
        curr = re.search(r"in\s+([A-Za-z]{3})\b", query)
        parsed["currency"] = curr.group(1).upper() if curr else "INR"

    # Post-process fields: normalize dates, IATA codes, defaults
    origin_raw = parsed.get("origin") or parsed.get("from") or ""
    dest_raw = parsed.get("destination") or parsed.get("to") or ""
    departure_raw = parsed.get("departure_date") or parsed.get("date") or ""
    return_raw = parsed.get("return_date")
    adults = parsed.get("adults") or 1
    non_stop = parsed.get("non_stop") or False
    currency = (parsed.get("currency") or "INR").upper()

    # Normalize dates
    dep_iso = parse_date_str(str(departure_raw)) if departure_raw else None
    ret_iso = parse_date_str(str(return_raw)) if return_raw else None

    # If LLM returned full ISO like 2024-09-25 but year is past, bump to next year
    now = datetime.now()
    if dep_iso:
        try:
            ddt = datetime.strptime(dep_iso, "%Y-%m-%d")
            if ddt.date() < now.date():
                # if date already past, assume next year
                ddt = ddt.replace(year=ddt.year + 1)
                dep_iso = ddt.strftime("%Y-%m-%d")
        except:
            pass

    # Normalize origin/destination to IATA
    origin_code = get_iata_code(str(origin_raw).strip()) if origin_raw else None
    dest_code = get_iata_code(str(dest_raw).strip()) if dest_raw else None

    # If not found but raw looks like 3-letter code, accept uppercase
    if not origin_code and isinstance(origin_raw, str) and re.fullmatch(r"[A-Za-z]{3}", origin_raw.strip()):
        origin_code = origin_raw.strip().upper()
    if not dest_code and isinstance(dest_raw, str) and re.fullmatch(r"[A-Za-z]{3}", dest_raw.strip()):
        dest_code = dest_raw.strip().upper()

    result = {
        "origin": origin_code,
        "destination": dest_code,
        "departure_date": dep_iso,
        "return_date": ret_iso,
        "adults": int(adults),
        "non_stop": bool(non_stop),
        "currency": currency
    }
    return result

# === Agents ===
flight_agent = Agent(
    role="Flight Search Assistant",
    goal="Help users find and recommend the best flights",
    backstory="You are a travel assistant that uses Amadeus API to fetch flight options.",
    llm=llm,
    tools=[search_flights_tool],
    verbose=True
)

query_agent = Agent(
    role="Query Understanding Assistant",
    goal="Convert user’s natural English request into structured flight search parameters",
    backstory="You are skilled at understanding travel queries and extracting key details.",
    llm=llm,
    tools=[parse_flight_query],
    verbose=True
)

hotel_agent = Agent(
    role="Hotel Recommendation Assistant",
    goal="Find good hotels for users at their destination with price and details",
    backstory="You are a travel assistant that recommends hotels via Amadeus API.",
    llm=llm,
    tools=[search_hotels_tool],
    verbose=True
)

# === Streamlit UI ===
st.title("Travel Assistant")
st.write("Search flights, hotels and more with ease")

query = st.text_input(
    "Enter your travel plan:",
    placeholder="e.g., I want a round trip from Bangalore to Delhi on 25th Sep returning 30th Sep, 1 adult, non-stop"
)

if st.button("Search Flights"):
    if not query.strip():
        st.warning("Please enter your query.")
    else:
        # Step 1: Parse query via Crew (single parse task)
        parse_task = Task(
            description=f"Parse this flight request: {query}",
            agent=query_agent,
            expected_output="Strict JSON with keys: origin (IATA), destination (IATA), departure_date (YYYY-MM-DD), return_date, adults, non_stop, currency"
        )
        crew = Crew(agents=[query_agent], tasks=[parse_task], verbose=True)
        parse_result = crew.kickoff()

        # Extract the parsed JSON (robust)
        parsed = None
        if hasattr(parse_result, "raw"):
            parsed = parse_result.raw
        else:
            parsed = parse_result

        if isinstance(parsed, dict):
            parsed = parsed.get("Final Output") or parsed.get("Final Answer") or parsed

        if isinstance(parsed, str):
            parsed = extract_json_from_text(parsed)

        # If still not dict, show error
        if not isinstance(parsed, dict):
            st.error("Failed to parse query reliably. Raw parser output:")
            st.code(str(parsed))
        else:
            # Ensure required fields
            origin = parsed.get("origin")
            dest = parsed.get("destination")
            dep = parsed.get("departure_date")
            ret = parsed.get("return_date")
            adults = parsed.get("adults", 1)
            non_stop = parsed.get("non_stop", False)
            currency = parsed.get("currency", "INR")

            if not origin or not dest or not dep:
                st.error("Parsed query is missing required fields (origin/destination/departure_date). See parsed output:")
                st.json(parsed)
            else:
                # Final safety: if origin/dest are not IATA, try lookup again
                if not re.fullmatch(r"[A-Z]{3}", origin):
                    origin_lookup = get_iata_code(origin)
                    if origin_lookup:
                        origin = origin_lookup
                if not re.fullmatch(r"[A-Z]{3}", dest):
                    dest_lookup = get_iata_code(dest)
                    if dest_lookup:
                        dest = dest_lookup
                    # Save for later use (e.g. hotels)
                st.session_state.dest = dest
                st.session_state.dep = dep
                st.session_state.ret = ret
                st.session_state.adults = adults
                st.session_state.currency = currency

                # Call search_flights directly (avoid agent re-calling tools)
                st.info(f"Searching flights: {origin} → {dest} on {dep} (return: {ret}) — {adults} adult(s), non-stop={non_stop}, currency={currency}")
                flights = _search_flights(origin=origin, destination=dest, departure_date=dep, currency=currency, return_date=ret)

                # Handle API errors
                if isinstance(flights, dict) and flights.get("error"):
                    st.error("Amadeus API error:")
                    st.text(flights.get("error"))
                elif isinstance(flights, list) and flights:
                    # If non_stop requested, filter out multi-stop
                    if non_stop:
                        flights = [f for f in flights if f.get("stops", 0) == 0 and (not f.get("return_stops") or f.get("return_stops") == 0)]
                    if not flights:
                        st.warning("No flights matched the non-stop filter.")
                    else:
                        # Show results as DataFrame
                        import pandas as pd
                        df = pd.DataFrame(flights)
                        st.success(f"Found {len(flights)} flight options")
                        st.dataframe(df)

                        # Show cheapest
                        def _price(f):
                            try:
                                return float(f.get("price", 1e12))
                            except:
                                return 1e12
                        cheapest = sorted(flights, key=_price)[0]
                        if cheapest.get("return_departure"):
                            st.info(
                                f"Cheapest round trip: {cheapest.get('airline','?')} at {cheapest.get('price','?')} {cheapest.get('currency','')}\n"
                                f"Out: {cheapest.get('departure','')} → {cheapest.get('arrival','')}\n"
                                f"Return: {cheapest.get('return_departure','N/A')} → {cheapest.get('return_arrival','N/A')}"
                            )
                        else:
                            st.info(
                                f"Cheapest one-way: {cheapest.get('airline','?')} at {cheapest.get('price','?')} {cheapest.get('currency','')}\n"
                                f"Dep: {cheapest.get('departure','')} → Arr: {cheapest.get('arrival','')}"
                            )
                else:
                    st.error("No flights found or unexpected response")
                    st.json(flights)
# === Hotels UI ===
st.subheader("Hotel Recommendations")

# Only show if we have parsed flight search results
if "dest" in st.session_state and "dep" in st.session_state and "ret" in st.session_state:
    dest = st.session_state.dest
    dep = st.session_state.dep
    ret = st.session_state.ret
    adults = st.session_state.adults
    currency = st.session_state.currency

    if st.button("Find Hotels at Destination"):
        dest = st.session_state.get("dest")
        dep = st.session_state.get("dep")
        ret = st.session_state.get("ret")
        adults = st.session_state.get("adults", 1)
        currency = st.session_state.get("currency", "USD")

        if not dest or not dep:
            st.error("Missing travel details. Please search flights first.")
        else:
            # Normalize city code
            city_map = {"JFK": "NYC", "EWR": "NYC", "LGA": "NYC", "CDG": "PAR", "ORY": "PAR"}
            city_code = city_map.get(dest, dest)

            # Ensure check-out date
            check_in = dep
            if ret:
                check_out = ret
            else:
                from datetime import datetime, timedelta
                check_out = (datetime.strptime(dep, "%Y-%m-%d") + timedelta(days=2)).strftime("%Y-%m-%d")

            st.info(f"Searching hotels in {city_code} from {check_in} to {check_out} for {adults} adult(s)...")
            hotels = _search_hotels(city_code, check_in, check_out, adults, currency)

            if isinstance(hotels, dict) and hotels.get("error"):
                st.error("Amadeus API error:")
                st.json(hotels)
            else:
                st.success("Hotel Recommendations:")

                for h in hotels:
                    with st.expander(f"🏨 {h['name']} — {h['price']} {h['currency']}"):
                        st.write(f"📍 **Address:** {h.get('address', 'N/A')}")
                        st.write(f"⭐ **Category:** {h.get('category', 'N/A')}")
                        st.write(f"📅 **Stay:** {h.get('check_in', '?')} → {h.get('check_out', '?')}")

                        # Google details
                        if h.get("google_rating"):
                            st.write(f"🌟 **Google Rating:** {h['google_rating']} ({h.get('google_reviews','0')} reviews)")
                        if h.get("google_website"):
                            st.write(f"🔗 [Website]({h['google_website']})")

                        if h.get("image"):
                            st.image(h["image"], use_container_width=True)

                        if h.get("amenities"):
                            st.write("🛎️ **Amenities:**")
                            st.write(", ".join(h["amenities"]))



# === Attractions & Activities ===
#st.subheader("Top Attractions & Activities")

#attractions = _search_attractions(city_code, limit=5)

#if isinstance(attractions, dict) and attractions.get("error"):
 #   st.error("Attractions API error:")
  #  st.json(attractions)
#else:
 #   for poi in attractions:
  #      with st.expander(f"📍 {poi['name']}"):
   #         st.write(f"🏷️ Category: {poi.get('category', 'N/A')}")
    #        if poi.get("tags"):
     #           st.write("🔖 Tags:", ", ".join(poi["tags"]))
      #      st.write(f"🌍 Location: {poi.get('lat')}, {poi.get('lon')}")
